import { Bot } from 'grammy';
import { filterListingMessage, detectListingExchange } from './filters.js';
import { extractUrl } from '../utils/text.js';
import { scrapeNotice } from '../scraper/notice_scraper.js';
import { parseNoticeForTicker } from '../scraper/parsers.js';
import { getLLMService } from '../llm/provider.js';
import { generatePressReleaseMessage, getExchangeImagePath } from '../publisher/press_release.js';
import { publishToMultipleChats } from '../publisher/telegram_publisher.js';
import { getDatabase } from '../storage/db.js';
import { withRetry, RETRY_CONFIG } from '../utils/retry.js';
import logger from '../utils/logger.js';

export interface ProcessingResult {
  success: boolean;
  reason?: string;
  ticker?: string;
  exchange?: string;
}

/**
 * Process a listing announcement message
 */
export async function processListingAnnouncement(
  bot: Bot,
  messageText: string,
  sourceChatId?: number
): Promise<ProcessingResult> {
  const db = getDatabase();
  const llm = getLLMService();

  try {
    // Step 1: Filter message
    const filterResult = filterListingMessage(messageText);
    if (!filterResult.passed) {
      logger.info({ reason: filterResult.reason }, 'Message filtered out');
      return { success: false, reason: filterResult.reason };
    }

    const exchange = filterResult.exchange!;
    logger.info({ exchange }, 'Listing announcement detected');

    // Step 2: Extract URL
    const url = extractUrl(messageText);
    if (!url) {
      logger.warn('No URL found in message');
      return { success: false, reason: 'no_url' };
    }

    logger.info({ url }, 'URL extracted from message');

    // Step 3: Scrape notice content (with retry)
    const scrapedNotice = await withRetry(
      () => scrapeNotice(url),
      RETRY_CONFIG.scraping
    );

    logger.info(
      { url, length: scrapedNotice.length },
      'Notice content scraped'
    );

    // Step 4: Parse ticker from content
    const parsed = parseNoticeForTicker(scrapedNotice.content);
    const ticker = parsed.ticker;

    logger.info({ ticker, exchange }, 'Ticker extracted');

    // NOTE: duplicate checking removed per user request — process all announcements

    // Step 6: Generate article with LLM (GPT) (with retry)
    const llmResponse = await withRetry(
      () => llm.generateArticle(exchange, scrapedNotice.content),
      RETRY_CONFIG.claude
    );

    logger.info(
      { exchange, ticker: llmResponse.ticker, title: llmResponse.title },
      'Article generated by LLM'
    );

    // Step 7: Generate press release message
    const pressReleaseMessage = generatePressReleaseMessage(
      llmResponse.title,
      llmResponse.article_message,
      llmResponse.ticker,
      exchange
    );

    const imagePath = getExchangeImagePath(exchange);

    logger.info({ exchange, ticker }, 'Press release message generated');

    // Step 8: Determine target chats
    const outputMode = process.env.OUTPUT_MODE || 'broadcast';
    let targetChatIds: number[] = [];

    // If this processing request originated from a chat message, reply only to that chat.
    if (sourceChatId) {
      targetChatIds = [sourceChatId];
    } else if (outputMode === 'source_only' && sourceChatId) {
      targetChatIds = [sourceChatId];
    } else if (outputMode === 'single') {
      const outputChatId = process.env.OUTPUT_CHAT_ID;
      if (outputChatId) {
        targetChatIds = [parseInt(outputChatId, 10)];
      }
    } else if (outputMode === 'broadcast') {
      const enabledChats = db.getAllEnabledChats();
      targetChatIds = enabledChats.map((chat) => chat.chat_id);
    }

    if (targetChatIds.length === 0) {
      logger.warn('No target chats found');
      return { success: false, reason: 'no_target_chats' };
    }

    logger.info({ targetChatIds, outputMode }, 'Publishing to target chats');

    // Step 9: Publish to chats (with retry)
    const results = await withRetry(
      async () => {
        const publishResults = await publishToMultipleChats(
          bot,
          targetChatIds,
          llmResponse.title,
          llmResponse.article_message,
          pressReleaseMessage,
          imagePath
        );

        // Check if at least one succeeded
        const hasSuccess = Array.from(publishResults.values()).some((r) => r.success);
        if (!hasSuccess) {
          throw new Error('All publish attempts failed');
        }

        return publishResults;
      },
      RETRY_CONFIG.telegram
    );

    const successCount = Array.from(results.values()).filter((r) => r.success).length;
    logger.info(
      { exchange, ticker, successCount, totalChats: targetChatIds.length },
      'Publishing completed'
    );

    // NOTE: marking listings as processed removed per user request

    // Step 11: Log success
    db.addJobLog({
      level: 'INFO',
      event: 'listing_processed',
      payload: JSON.stringify({
        exchange,
        ticker: llmResponse.ticker,
        url,
        successCount,
        totalChats: targetChatIds.length,
      }),
    });

    return {
      success: true,
      ticker: llmResponse.ticker,
      exchange,
    };
  } catch (error) {
    logger.error({ error, messageText }, 'Failed to process listing announcement');

    // Log failure
    db.addJobLog({
      level: 'ERROR',
      event: 'listing_processing_failed',
      payload: JSON.stringify({
        error: error instanceof Error ? error.message : String(error),
        messageText: messageText.substring(0, 200),
      }),
    });

    return {
      success: false,
      reason: 'processing_error',
    };
  }
}

/**
 * Setup message handler for monitoring chats
 */
export function setupMessageHandler(bot: Bot) {
  bot.on('message:text', async (ctx) => {
    const chatId = ctx.chat.id;
    const db = getDatabase();
    
    // Ensure chat is recorded and enabled by default when bot receives a message.
    // This makes the bot active in chats it has been invited to without requiring /on.
    let setting = db.getChatSetting(chatId);
    if (!setting) {
      db.setChatEnabled(chatId, true);
      setting = db.getChatSetting(chatId);
      logger.info({ chatId }, 'New chat detected — auto-enabled');
    }

    const enabled = setting ? setting.enabled === 1 : false;

    if (!enabled) {
      logger.debug({ chatId }, 'Bot is disabled in this chat, skipping');
      return;
    }

    let messageText = ctx.message.text;

    // Extract URLs from entities (hyperlinks)
    if (ctx.message.entities) {
      logger.debug({
        entityCount: ctx.message.entities.length
      }, 'Message entities detected');

      for (const entity of ctx.message.entities) {
        // Check if entity has url property (for text_link type)
        if (entity.type === 'text_link' && 'url' in entity) {
          const url = (entity as any).url;
          messageText += ' ' + url;
          logger.debug({ url }, 'Extracted URL from text_link entity');
        } else if (entity.type === 'url') {
          // Regular URL is already in the text
          const urlText = messageText.substring(entity.offset, entity.offset + entity.length);
          logger.debug({ urlText }, 'URL entity found (already in text)');
        }
      }
    }

    // Detailed debug logging for diagnosis: show chat type, from, entities, and filter diagnostics
    logger.debug(
      {
        chatId,
        chatType: ctx.chat?.type,
        fromId: ctx.from?.id,
        entitiesCount: ctx.message.entities ? ctx.message.entities.length : 0,
        messagePreview: messageText.substring(0, 400),
      },
      'Received message from chat'
    );

    // Quick filter diagnostics to help explain why some chats produce no action
    try {
      const detected = detectListingExchange(messageText);
      const normalizedSnippet = messageText.replace(/\s+/g, '').substring(0, 200);
      logger.debug({ detected, normalizedSnippet }, 'Filter diagnostics');
    } catch (err) {
      logger.debug({ err }, 'Filter diagnostics failed');
    }

    await processListingAnnouncement(bot, messageText, chatId);
  });

  // Also handle channel posts (when the bot is added to a channel and receives posts)
  bot.on('channel_post', async (ctx) => {
    // channel_post updates have channelPost instead of message
    const post = (ctx as any).channelPost as any;
    const chatId = post?.chat?.id;
    if (!chatId) return;

    const db = getDatabase();

    let setting = db.getChatSetting(chatId);
    if (!setting) {
      db.setChatEnabled(chatId, true);
      setting = db.getChatSetting(chatId);
      logger.info({ chatId }, 'New channel detected — auto-enabled');
    }

    const enabled = setting ? setting.enabled === 1 : false;
    if (!enabled) return;

    let messageText = post.text || post.caption || '';

    // No entities for channel_post in ctx.message.entities; attempt to extract URLs directly
    logger.info({ chatId, messagePreview: messageText.substring(0, 100) }, 'Processing channel_post from enabled channel');

    await processListingAnnouncement(bot, messageText, chatId);
  });

  logger.info('Message handler setup - monitoring all enabled chats');
}
