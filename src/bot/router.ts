import { Bot } from 'grammy';
import { filterListingMessage } from './filters.js';
import { extractUrl } from '../utils/text.js';
import { scrapeNotice } from '../scraper/notice_scraper.js';
import { parseNoticeForTicker } from '../scraper/parsers.js';
import { getClaudeService } from '../llm/claude.js';
import { generatePressReleaseMessage, getExchangeImagePath } from '../publisher/press_release.js';
import { publishToTelegram, publishToMultipleChats } from '../publisher/telegram_publisher.js';
import { getDatabase } from '../storage/db.js';
import { withRetry, RETRY_CONFIG } from '../utils/retry.js';
import logger from '../utils/logger.js';

export interface ProcessingResult {
  success: boolean;
  reason?: string;
  ticker?: string;
  exchange?: string;
}

/**
 * Process a listing announcement message
 */
export async function processListingAnnouncement(
  bot: Bot,
  messageText: string,
  sourceChatId?: number
): Promise<ProcessingResult> {
  const db = getDatabase();
  const claude = getClaudeService();

  try {
    // Step 1: Filter message
    const filterResult = filterListingMessage(messageText);
    if (!filterResult.passed) {
      logger.info({ reason: filterResult.reason }, 'Message filtered out');
      return { success: false, reason: filterResult.reason };
    }

    const exchange = filterResult.exchange!;
    logger.info({ exchange }, 'Listing announcement detected');

    // Step 2: Extract URL
    const url = extractUrl(messageText);
    if (!url) {
      logger.warn('No URL found in message');
      return { success: false, reason: 'no_url' };
    }

    logger.info({ url }, 'URL extracted from message');

    // Step 3: Scrape notice content (with retry)
    const scrapedNotice = await withRetry(
      () => scrapeNotice(url),
      RETRY_CONFIG.scraping
    );

    logger.info(
      { url, length: scrapedNotice.length },
      'Notice content scraped'
    );

    // Step 4: Parse ticker from content
    const parsed = parseNoticeForTicker(scrapedNotice.content);
    const ticker = parsed.ticker;

    logger.info({ ticker, exchange }, 'Ticker extracted');

    // Step 5: Check if already processed (deduplication)
    if (db.isListingProcessed(exchange, ticker)) {
      logger.info({ exchange, ticker }, 'Listing already processed (duplicate)');
      return {
        success: false,
        reason: 'duplicate',
        ticker,
        exchange,
      };
    }

    // Step 6: Generate article with Claude (with retry)
    const claudeResponse = await withRetry(
      () => claude.generateArticle(exchange, scrapedNotice.content),
      RETRY_CONFIG.claude
    );

    logger.info(
      { exchange, ticker: claudeResponse.ticker, title: claudeResponse.title },
      'Article generated by Claude'
    );

    // Step 7: Generate press release message
    const pressReleaseMessage = generatePressReleaseMessage(
      claudeResponse.title,
      claudeResponse.article_message,
      claudeResponse.ticker,
      exchange
    );

    const imagePath = getExchangeImagePath(exchange);

    logger.info({ exchange, ticker }, 'Press release message generated');

    // Step 8: Determine target chats
    const outputMode = process.env.OUTPUT_MODE || 'broadcast';
    let targetChatIds: number[] = [];

    if (outputMode === 'source_only' && sourceChatId) {
      targetChatIds = [sourceChatId];
    } else if (outputMode === 'single') {
      const outputChatId = process.env.OUTPUT_CHAT_ID;
      if (outputChatId) {
        targetChatIds = [parseInt(outputChatId, 10)];
      }
    } else if (outputMode === 'broadcast') {
      const enabledChats = db.getAllEnabledChats();
      targetChatIds = enabledChats.map((chat) => chat.chat_id);
    }

    if (targetChatIds.length === 0) {
      logger.warn('No target chats found');
      return { success: false, reason: 'no_target_chats' };
    }

    logger.info({ targetChatIds, outputMode }, 'Publishing to target chats');

    // Step 9: Publish to chats (with retry)
    const results = await withRetry(
      async () => {
        const publishResults = await publishToMultipleChats(
          bot,
          targetChatIds,
          claudeResponse.article_message,
          pressReleaseMessage,
          imagePath
        );

        // Check if at least one succeeded
        const hasSuccess = Array.from(publishResults.values()).some((r) => r.success);
        if (!hasSuccess) {
          throw new Error('All publish attempts failed');
        }

        return publishResults;
      },
      RETRY_CONFIG.telegram
    );

    const successCount = Array.from(results.values()).filter((r) => r.success).length;
    logger.info(
      { exchange, ticker, successCount, totalChats: targetChatIds.length },
      'Publishing completed'
    );

    // Step 10: Mark as processed
    db.markListingProcessed({
      exchange,
      ticker: claudeResponse.ticker,
      notice_url: url,
    });

    // Step 11: Log success
    db.addJobLog({
      level: 'INFO',
      event: 'listing_processed',
      payload: JSON.stringify({
        exchange,
        ticker: claudeResponse.ticker,
        url,
        successCount,
        totalChats: targetChatIds.length,
      }),
    });

    return {
      success: true,
      ticker: claudeResponse.ticker,
      exchange,
    };
  } catch (error) {
    logger.error({ error, messageText }, 'Failed to process listing announcement');

    // Log failure
    db.addJobLog({
      level: 'ERROR',
      event: 'listing_processing_failed',
      payload: JSON.stringify({
        error: error instanceof Error ? error.message : String(error),
        messageText: messageText.substring(0, 200),
      }),
    });

    return {
      success: false,
      reason: 'processing_error',
    };
  }
}

/**
 * Setup message handler for monitoring chats
 */
export function setupMessageHandler(bot: Bot, sourceChatId: number) {
  bot.on('message:text', async (ctx) => {
    const chatId = ctx.chat.id;
    const db = getDatabase();

    // Check if bot is enabled in this chat
    const setting = db.getChatSetting(chatId);
    const enabled = setting ? setting.enabled === 1 : false;

    if (!enabled) {
      logger.debug({ chatId }, 'Bot is disabled in this chat, skipping');
      return;
    }

    let messageText = ctx.message.text;

    // Extract URLs from entities (hyperlinks)
    if (ctx.message.entities) {
      logger.debug({
        entityCount: ctx.message.entities.length
      }, 'Message entities detected');

      for (const entity of ctx.message.entities) {
        // Check if entity has url property (for text_link type)
        if (entity.type === 'text_link' && 'url' in entity) {
          const url = (entity as any).url;
          messageText += ' ' + url;
          logger.debug({ url }, 'Extracted URL from text_link entity');
        } else if (entity.type === 'url') {
          // Regular URL is already in the text
          const urlText = messageText.substring(entity.offset, entity.offset + entity.length);
          logger.debug({ urlText }, 'URL entity found (already in text)');
        }
      }
    }

    logger.info({
      chatId,
      messagePreview: messageText.substring(0, 100)
    }, 'Processing message from enabled chat');

    await processListingAnnouncement(bot, messageText, chatId);
  });

  logger.info('Message handler setup - monitoring all enabled chats');
}
